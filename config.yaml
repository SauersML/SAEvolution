simulation:
  num_generations: 5
  population_size: 6
  games_per_agent_target: 1 # Explicitly set: number of games each agent aims to play per generation.

agent:
  model_id: 'meta-llama/Llama-3.3-70B-Instruct'
  initial_wealth: 30.0
  initial_genome: {} # Represents an empty genome; features and their activations are learned during evolution.

evolution:
  learning_rate: 0.1

  # This identifies features activated by the model during that specific game.
  # The following parameters control how features are selected from this inspection.
  inspect_top_k: 10       # For client.features.inspect(...).top(k).
                          # This retrieves the top 'k' features that were most salient during the game transcript
                          # (based on frequency of strong activation and then sorted by aggregated_value)

  inspect_aggregate_by: "max" # Method for client.features.inspect(...) to calculate the 'salience'
                          # (the aggregated activation value associated with each feature by .top(k)).
                          # Options:
                          #   "max": Peak activation strength of the feature during the transcript.
                          #   "sum": Sum of all activation strengths for the feature.
                          #   "mean": Average activation strength when the feature was active.
                          #   "frequency": Count of tokens where the feature was active (above a small threshold).

  num_winning_features: 5 # Of the 'inspect_top_k' features identified from a WINNING game,
                          # use this many (the ones with the highest aggregated activation) to REINFORCE in the offspring.
  num_losing_features: 5  # Of the 'inspect_top_k' features identified from a LOSING game,
                          # use this many (the ones with the highest aggregated activation) to SUPPRESS in the offspring.
                          # Note: Ties result in no inspection-based genome update.

  activation_min: -5.0    # Minimum allowed activation value for a feature.
  activation_max: 5.0     # Maximum allowed activation value for a feature.
  target_positive: 1.0    # Target activation for features reinforced due to winning (if update_method is 'target').
  target_negative: -0.1   # Target activation for features suppressed due to losing (if update_method is 'target').
  update_method: 'increment' # Method for updating feature activations. Options: 'increment', 'target'.

game:
  interaction_turns_per_agent: 3 # Each agent takes this many turns in a game. Total game turns = 2 * this value.
  betting:
    strategy: 'fixed'         # Betting strategy. Options: 'fixed' (others could be implemented).
    fixed_amount: 5.0         # Bet amount if strategy is 'fixed'.
    min_bet: 1.0              # Minimum allowed bet.
    max_bet_ratio: 0.5        # Maximum bet as a ratio of an agent's current wealth (e.g., 0.5 means up to 50% of wealth).
    max_loss_multiplier: 1.0  # Multiplier for the loser's bet to determine their maximum potential loss.
    max_gain_ratio: 2.0       # Max gain for the winner as a ratio of their *own* pre-win wealth (e.g., 2.0 means winner can gain up to 1.0x their pre-win wealth from this game).

round: # Configuration for how a round of games within a generation is structured.
  pairing_strategy: 'random_shuffle' # Strategy for pairing agents for games. Options: 'random_shuffle'.

generation:
  scenario:
    prompt: |
      Generate a two-player game scenario using the following XML-style tags. Your entire output must consist ONLY of these tags and their content, in sequence. Do not include any other text, explanations, or formatting outside of the tags themselves.

      Later, you will be randomly assigned one of the roles. The game can be anything: any concept, style, description, rules, scenario, setting, constraints, etc.

      The game will be purely text-based and multi-turn. Define win criteria clearly: avoid having to tie if possible.
      
      The required tags and their expected content are:

      1.  ` <context> ... </context> `
          *   Content: Describe the game setting and relevant background information. Note, each role gets three messages each (six total).

      2.  ` <roles> ... </roles> `
          *   Content: Define the two player roles. For clarity within the content, you may structure this as "Role A: [description for Role A]" and "Role B: [description for Role B]".

      3.  ` <objectives> ... </objectives> `
          *   Content: Detail what each player or role aims to achieve. The text content *within this tag* MUST include the word 'objective'. Explain other ways to determine the objective(s) to prevent a tie from occuring.

      4.  ` <win_criteria> ... </win_criteria> `
          *   Content: Explain the conditions under which a player or role wins the game. The text content *within this tag* MUST include the phrase 'win criteria'. Explain any softer win criteria to avoid a tie.

      5.  ` <tie_criteria> ... </tie_criteria> `
          *   Content: Give reasoning for why a tie should be improbable. Explain the conditions under which the game results in a tie. Ties should typically be reserved for exceptional circumstances. If ties are not possible, explicitly state that. The text content *within this tag* MUST include the phrase 'tie criteria'.

      6.  ` <proposer_role> ... </proposer_role> `
          *   Content: Indicate which role is designated as the proposer or first mover for this game setup. The content of this tag MUST be exactly 'Role A' or 'Role B'.

      Make sure your output is only the sequence of these tags with their content.
    max_tokens: 1000
    temperature: 0.7
  response:
    prompt_template: |
      Scenario:
      {scenario}

      Your Role: {role}

      Conversation History:
      {history}

      {role} (Respond according to your role and objective):
    max_tokens: 1000
    temperature: 0.6

adjudicator:
  model_id: 'meta-llama/Llama-3.3-70B-Instruct'
  prompt_template: |
      Analyze the interaction based on the rules and objectives defined in the scenario description.
      The Interaction Transcript will label each message with an identifier like "A1" (Role A's first message), "B1" (Role B's first message), "A2", etc.

      The contents of your reply should be contained within XML tags, so begin your response with the first XML opening tag ("<scratchpad>").

      Your analysis should proceed in three steps, with XML tags for each:

      1. <scratchpad>
         Think step-by-step here about the game flow, key moments, and how each player's actions related to the win criteria and objectives.
         Identify which role, achieved its objectives or better met the win criteria, even if the objectives were not achieved.
         If a winner is clear, identify the single message from the WINNING role that was most pivotal or representative of their win.
         Also, identify the single message from the LOSING role that was most pivotal or representative of their loss or a key mistake.
         If it's a Tie, you do not need to identify win/loss messages. If there is any signal or lean as to who is doing better, you should assign a win instead of a tie.
         Note: assign ties only when the scenario and game context is very evenly matched with no possible way to decide a winner. If one role is doing better, assign it to win.
         You may also plan how to give the other responses using the XML tags as described.
      </scratchpad>

      2. <outcome>
         Based on your analysis of the interaction, determine the outcome. Respond with ONLY ONE of the following exact phrases: 'Role A Wins', 'Role B Wins', or 'Tie'.
      </outcome>

      3. If there is a winner and loser (i.e., not a 'Tie'):
         <win_message_id>[WINNER_MSG_ID]</win_message_id>
         <lose_message_id>[LOSER_MSG_ID]</lose_message_id>
         
         Replace [WINNER_MSG_ID] with the message identifier of the winner's most critical message leading to or responsible for the win.
         Replace [LOSER_MSG_ID] with the message identifier of the loser's message which most contributed to the loss.

         There must be only one message ID inside each of the two tags.

         Outcome MUST be ONLY ONE of these options, verbatim: 1. <outcome>Role A Wins</outcome>, 2. <outcome>Role B Wins</outcome>, or 3. <outcome>Tie</outcome>
         You must refer to the roles as "Role A" and "Role B" and not as any other names.
        
         If the outcome is 'Tie', you can omit these tags.

      Scenario Description:
      {scenario}

      Interaction Transcript (with message identifiers):
      [Beginning of game transcript]
      {transcript_with_ids}
      [End of game transcript]

      Provide your full response using the XML tags as described.

      Your task is to analyze the provided game transcript and scenario, not to continue the game.

      If the game is unfinished, do your best to judge anyway.

      Your response will be in this format: <scratchpad> ... </scratchpad> <outcome> ... </outcome> <win_message_id> ... </win_message_id> <lose_message_id> ... </lose_message_id>

      win_message_id and lose_message_id must each contain two characters only within the tags. This is because the messages IDs are only two characters.

      1. scratchpad can have any content you want.
      2. outcome is extremely strict in must have only ONE of the three possible options. Your job is to choose which of the three to pick. Do NOT give any rational or explanation here.
      3. win_message_id and lose_message_id must be one of the following: A1, A2, A3, B1, B2, or B3. This is strict: do not describe the messages or give reasoning here.
      
      Provide your full response using the XML tags as described. Start your response with the <scratchpad> tag now. Then, write the <outcome> tag. Finally, provide the two tags for the winning and losing message_id.
      
  max_tokens: 5000
  temperature: 0.0

logging:
  log_level: DEBUG # Logging verbosity. Options: DEBUG, INFO, WARNING, ERROR, CRITICAL.
  log_directory: logs # Directory where log files will be saved.

state_saving:
  enabled: True # Whether to save simulation state.
  interval: 1   # Save state every N generations.
  directory: simulation_state # Base directory for saving simulation run data.

api_retries:
  max_retries: 3      # Maximum number of retries for failed API calls.
  initial_delay: 1.0  # Initial delay in seconds before the first retry.
  backoff_factor: 2.0 # Multiplier for increasing delay between retries (e.g., 1s, 2s, 4s, ...).

goodfire:
  api_key_env_var: 'GOODFIRE_API_KEY' # Name of the environment variable holding the Goodfire API key.
  base_url: null # Explicitly set to null to use the Goodfire SDK's default API URL.
